//lay1 module

module la1_mod (

	input 					clk,
	input 					rst_n,
	input						en,
	input		 [8:0]		x,		//input sample
	
	output reg				valid,
	output reg[31:0]		y0,	
	output reg[31:0]		y1,	
	output reg[31:0]		y2,	
	output reg[31:0]		y3

);

parameter MULT_LATENCY = 4'd5,
			 ADD_LATENCY  = 4'd7;

// state code			 
parameter Sidle=5'b00000,		//IDLE
			 S0=5'b00001,			//load data & mult
			 S1=5'b00010,			//mult waite
			 S2=5'b00100,			//load data & add
			 S3=5'b01000,			//add waite
			 S4=5'b10000,			//crossroad judgement
			 S5=5'b00011;			//bias add loading

			 
reg[4:0]		state;
reg[4:0]		next_state;
reg[1:0]		neuron;
reg[3:0]		matrix_step;
reg[31:0]	mult_dataa;
reg[31:0]	mult_datab;
wire[31:0]	mult_result;
reg[3:0]		mult_latency;
reg[31:0]	add_dataa;
reg[31:0]	add_datab;
wire[31:0]	add_result;
reg[3:0]		add_latency;
reg[10:0]	rom_addr;
wire[31:0]	rom_data;
reg[31:0]	y;


always @(posedge clk or negedge rst_n) 
begin
	if(!rst_n) state<=Sidle;
		//current_state <= Sidle;
	else state<=next_state;
		//current_state <= next_state;	
end

// Next-state combinational logic
always @*
begin
case(state)
Sidle:	if (en)	next_state=S0;
S0:		if(valid==1'b1) next_state=Sidle;
			else	next_state=S1;
S1:		if	(!mult_latency)	next_state=S2;
S2:		next_state=S3;
S3:		if (!add_latency)		next_state=S4;
S4:		if(matrix_step==4'd9)		next_state=S5;
			else	next_state=S0;
S5:		next_state=S3;
default: next_state=Sidle;
endcase
end


always@(posedge clk or negedge rst_n)
if(!rst_n)
begin
	y0 <= 32'h0;
	y1 <= 32'h0;
	y2 <= 32'h0;
	y3 <= 32'h0;
	valid<= 1'b0;
	neuron <= 2'd0; 
	matrix_step <= 4'd0;
	rom_addr <= 11'd0;
	mult_dataa <= 32'h00000000;
	mult_datab <= 32'h00000000;
	mult_latency<=MULT_LATENCY;
	add_latency <=ADD_LATENCY;
end
else
begin 
case(state)
  Sidle: begin
		y0 <= 32'h0;
		y1 <= 32'h0;
		y2 <= 32'h0;
		y3 <= 32'h0;
		valid<= 1'b0;
		neuron <= 2'd0;
		matrix_step <= 4'd0;
		 end
     S0: begin 
	    if (x[matrix_step])	mult_dataa <= 32'h3f800000;
		 else		mult_dataa <= 32'h00000000;			//updating...
		 mult_datab <= rom_data;
		 rom_addr <= rom_addr + 11'd4;			//prepare for next multiplitation
		 end
     S1: begin
	    mult_latency <= mult_latency - 1;
		 end
     S2: begin
		 mult_latency <= MULT_LATENCY;		//restore latency first
		 add_dataa <= mult_result;
		 add_datab <= y;
		 end
     S3: begin 
		 add_latency <= add_latency - 1;
		 end
	  S4: begin
		 add_latency <= ADD_LATENCY;			// restore latency first
//	    y[neuron] <= add_result;

		 case(neuron)
		 0 : y0 <= add_result;
	 	 1 : y1 <= add_result;
		 2 : y2 <= add_result;
		 3 : y3 <= add_result;
		 default : y <= y;
		 endcase

	    if(neuron==2'd3 && matrix_step==4'd8)	begin
			valid <= 1'b1;
		 end
		 else if (matrix_step == 4'd9)	begin		// end of a neuron
			matrix_step <= 4'd0;
			neuron <= neuron + 1;
		 end
		 else if (matrix_step == 4'd8)	begin		// prepare to add bias
			matrix_step <= matrix_step + 1;
			rom_addr <= 11'd36 + neuron;
		 end
		 else matrix_step <= matrix_step + 1;
		 end
	  S5: begin 
		 add_dataa <= rom_data;
		 add_datab <= y;
		 end
default: begin
	 
		 end
endcase
end

always@(posedge clk or negedge rst_n)
if (!rst_n)	
	y <= 32'd0;
else
begin
	case(neuron)
		0 : y <= y0;
		1 : y <= y1;
		2 : y <= y2;
		3 : y <= y3;
	default : y <= y;
	endcase
end



rom rom_u(
	.clock			(clk),
	.address_a		(rom_addr),
	.address_b		(),
	.q_a				(rom_data),
	.q_b				()
);


// Add module with 7 latency
ALFTP_ADD_SUB add_1(
	.clock			(clk),
	.aclr				(~rst_n),
	.dataa			(add_dataa),
	.datab			(add_datab),
	.result			(add_result)
);

// MULT module with 5 latency
ALTFP_MULT	mult_1(
	.clock			(clk),
	.aclr				(~rst_n),
	.dataa			(mult_dataa),
	.datab			(mult_datab),
	.result			(mult_result)
);
endmodule